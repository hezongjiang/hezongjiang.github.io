---
title: Java 垃圾回收(GC)机制
catalog: true
date: 2019-10-22 22:49:47
subtitle:
header-img: jvm.jpeg
tags: 服务端开发
---
## 一、为什么要进行垃圾回收
随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多，其中有很多对象再也用不到，这些用不到的对象就被称之为垃圾，如果不及时进行垃圾回收，必然会带来程序性能的下降，甚至会因为可用内存不足造成一些不必要的系统异常。



垃圾回收机制主要是对 JVM 中堆内存进行管理，如果对 JVM 相关的概念还不了解，可以看一看{% post_link JVM-从入门到出门 《JVM从入门到出门》 %}这篇文章。

## 二、如何判定对象是否为垃圾

**1、引用计数法**
给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是垃圾。

优点是执行效率高，缺点是无法解决对象之间相互循环引用的问题。

**2、可达性分析算法**
以 GC Roots 为起始点进行搜索，判断对象的引用链是否可达，可达的对象都是存活的，不可达的对象可被回收。GC Roots 一般包含以下内容：
* 虚拟机栈中局部变量表中引用的对象
* 本地方法栈中 JNI 中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中的常量引用的对象

> **对象死亡（被回收）前的最后一次挣扎:**
即使在可达性分析算法中不可达的对象，也并非是“必死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。
第一次标记：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；
第二次标记：在第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。在 `finalize()` 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。
第二次标记成功的对象将真的会被回收，如果对象在 `finalize()` 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。

## 三、回收垃圾的算法
回收垃圾的算法主要有 4 种：标记清除算法， 标记整理算法，复制算法，分代收集算法。下面分别介绍。

**1、标记清除**

标记：从 GC Roots 为起始点进行扫描，如果是活动对象，则程序会在对象头部打上标记。
清除：对堆内存从头到尾进行线性遍历，回收不可达对象。

![标记清除](https://upload-images.jianshu.io/upload_images/2708793-230202075298427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

但是，标记清除算法会产生大量不连续的内存碎片，导致无法给大对象分配内存。例如上图中 B 与 E 之间只剩 2 格，若有一个新对象要占用 3 格，则需要开辟另外的内存或者 Full GC。

**2、标记整理**

标记：从 GC Roots 为起始点进行扫描，如果是活动对象，则程序会在对象头部打上标记。
整理：移动所有存活对象，且按照内存地址次序依次排列，然后将末端以后的内存地址全部回收。

![标记整理](https://upload-images.jianshu.io/upload_images/2708793-d8605c893b6f7154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


弥补了标记清除算法的不足，不会产生内存碎片。但是需要移动大量对象，处理效率比较低。

**3、复制算法**

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

![复制算法](https://upload-images.jianshu.io/upload_images/2708793-41c71af018979e78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

不会产生内存碎片问题，顺序分配内存，执行效率高，但每次只使用了一半的内存，未免有点浪费。


**4、分代收集**

分代收集实际上就是将上述 3 种算法综合起来，针对不同的区域，采用不同的方法，按照对象的生命周期的不同划分区域，采用不同的垃圾回收算法，以提高 JVM 回收效率。

Java 堆分为两部分，Java 堆 = 新生代 + 老年代，默认分别占堆空间为 1/3、2/3；其中，新生代 = Eden + From Survivor + To Survivor，默认为 8:1:1。这样划分是由于对象生存周期的特殊性，针对不同的对象，采用不同的方法。

![Java 堆内存划分](https://upload-images.jianshu.io/upload_images/2708793-7c4e4e04b37e8ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

新生代使用：复制算法
老年代使用：标记清除 或者 标记整理 算法

所有的对象都在 Eden 区创建，并且大部分新生代的对象都是“朝生夕灭”，只有少量对象能存活下来，所以在新生代采用复制算法，只有少量对象需要复制，这样最划算。而在老年代，大部分对象任然会继续存活下来，此时采用标记整理或者标记清除算法，这样最划算。

> 对象如何晋升到老年代？
1、经历一定次数的 Minor GC 任然存活的对象，默认 15 次；
2、Eden 区或 Survivor 区域存放不下的对象；
3、新生成的大对象，直接放入老年代。

## 四、常见的垃圾收集器
**Serial 垃圾收集器（单线程，复制算法）**
单线程收集，进行垃圾收集时必须暂停所有工作线程。但是它简单高效，JVM Client 模式下默认的年轻代收集器。

![串行收集器](https://upload-images.jianshu.io/upload_images/2708793-f7b90a7a40bade85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**ParNew 垃圾收集器（多线程，复制算法）**
多线程收集器，其他行为特点与 Serial 一样。

**Parallel Scavenge 垃圾收集器（多线程，复制算法）**
Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：
Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。
ParNew：追求降低用户停顿时间，适合交互式应用。

**Serial Old 垃圾收集器（单线程，标记整理算法）**
Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。

**CMS 垃圾收集器**
CMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得**用户线程和 GC 线程并发执行**，因此在垃圾收集过程中用户也不会感到明显的卡顿。

具体执行过程：初始标记(STW) --> 并发标记 --> 重新标记(STW) --> 并发清除 --> 重新设置

![并发执行](https://upload-images.jianshu.io/upload_images/2708793-046047f32e1a25ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

CMS 收集器是并发收集，有两次 Stop The Words，两次标记，因为 GC 线程和应用线程同时执行，好比你妈在打扫房间，你还在扔纸屑，可能产生新的引用关系。

CMS 的缺点：吞吐量低，无法处理浮动垃圾，导致频繁 Full GC，使用“标记-清除”算法产生碎片空间。

**G1 垃圾收集器**
G1 是一款面向服务端应用的垃圾收集器，它弱化了新生代和老年代的概念，虽然还保留了新生代和来年代的概念，但新生代和老年代不再是物理隔离的了，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。

![G1](https://upload-images.jianshu.io/upload_images/2708793-b369ac262cab3de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。